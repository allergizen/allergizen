function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { useSpacingFunc } from './SpacingFuncContext';

const Box = _ref => {
  let {
    as,
    h,
    minH,
    maxH,
    w,
    minW,
    maxW,
    m,
    mt,
    mr,
    mb,
    ml,
    ms,
    me,
    mh,
    mv,
    p,
    pt,
    pr,
    pb,
    pl,
    ps,
    pe,
    ph,
    pv,
    borderStyle,
    border,
    borderTop,
    borderRight,
    borderBottom,
    borderLeft,
    borderStart,
    borderEnd,
    borderColor,
    borderTopColor,
    borderRightColor,
    borderBottomColor,
    borderLeftColor,
    borderStartColor,
    borderEndColor,
    radius,
    topLeftRadius,
    topRightRadius,
    bottomLeftRadius,
    bottomRightRadius,
    topStartRadius,
    topEndRadius,
    bottomStartRadius,
    bottomEndRadius,
    position,
    top,
    right,
    bottom,
    left,
    start,
    end,
    bg,
    opacity,
    zIndex,
    overflow,
    style,
    ...rest
  } = _ref;
  const spacingFunc = useSpacingFunc();
  const boxStyle = useMemo(() => {
    const styleObj = {};
    styleObj.height = spacingFunc(h);
    styleObj.minHeight = spacingFunc(minH);
    styleObj.maxHeight = spacingFunc(maxH);
    styleObj.width = spacingFunc(w);
    styleObj.minWidth = spacingFunc(minW);
    styleObj.maxWidth = spacingFunc(maxW);
    styleObj.margin = spacingFunc(m);
    styleObj.marginTop = spacingFunc(mt);
    styleObj.marginRight = spacingFunc(mr);
    styleObj.marginBottom = spacingFunc(mb);
    styleObj.marginLeft = spacingFunc(ml);
    styleObj.marginStart = spacingFunc(ms);
    styleObj.marginEnd = spacingFunc(me);
    styleObj.marginHorizontal = spacingFunc(mh);
    styleObj.marginVertical = spacingFunc(mv);
    styleObj.padding = spacingFunc(p);
    styleObj.paddingTop = spacingFunc(pt);
    styleObj.paddingRight = spacingFunc(pr);
    styleObj.paddingBottom = spacingFunc(pb);
    styleObj.paddingLeft = spacingFunc(pl);
    styleObj.paddingStart = spacingFunc(ps);
    styleObj.paddingEnd = spacingFunc(pe);
    styleObj.paddingHorizontal = spacingFunc(ph);
    styleObj.paddingVertical = spacingFunc(pv);
    styleObj.borderStyle = borderStyle;
    styleObj.borderWidth = border;
    styleObj.borderTopWidth = borderTop;
    styleObj.borderRightWidth = borderRight;
    styleObj.borderBottomWidth = borderBottom;
    styleObj.borderLeftWidth = borderLeft;
    styleObj.borderStartWidth = borderStart;
    styleObj.borderEndWidth = borderEnd;
    styleObj.borderColor = borderColor;
    styleObj.borderTopColor = borderTopColor;
    styleObj.borderRightColor = borderRightColor;
    styleObj.borderBottomColor = borderBottomColor;
    styleObj.borderLeftColor = borderLeftColor;
    styleObj.borderStartColor = borderStartColor;
    styleObj.borderEndColor = borderEndColor;
    styleObj.borderRadius = radius;
    styleObj.borderTopLeftRadius = topLeftRadius;
    styleObj.borderTopRightRadius = topRightRadius;
    styleObj.borderBottomLeftRadius = bottomLeftRadius;
    styleObj.borderBottomRightRadius = bottomRightRadius;
    styleObj.borderTopStartRadius = topStartRadius;
    styleObj.borderTopEndRadius = topEndRadius;
    styleObj.borderBottomStartRadius = bottomStartRadius;
    styleObj.borderBottomEndRadius = bottomEndRadius;
    styleObj.position = position;
    styleObj.top = top;
    styleObj.right = right;
    styleObj.bottom = bottom;
    styleObj.left = left;
    styleObj.start = start;
    styleObj.end = end;
    styleObj.backgroundColor = bg;
    styleObj.opacity = opacity;
    styleObj.zIndex = zIndex;
    styleObj.overflow = overflow;
    return styleObj;
  }, [h, minH, maxH, w, minW, maxW, m, mt, mr, mb, ml, ms, me, mh, mv, p, pt, pr, pb, pl, ps, pe, ph, pv, borderStyle, border, borderTop, borderRight, borderBottom, borderLeft, borderStart, borderEnd, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderStartColor, borderEndColor, radius, topLeftRadius, topRightRadius, bottomLeftRadius, bottomRightRadius, topStartRadius, topEndRadius, bottomStartRadius, bottomEndRadius, position, top, right, bottom, left, start, end, bg, opacity, zIndex, overflow, spacingFunc]);

  if (as) {
    return /*#__PURE__*/React.cloneElement(as, {
      style: [boxStyle, style, as.props.style],
      ...rest
    });
  }

  return /*#__PURE__*/React.createElement(View, _extends({
    style: [boxStyle, style]
  }, rest));
};

export default Box; // export interface FlexStyle {
//   backfaceVisibility?: "visible" | "hidden";
//   aspectRatio?: number;
//   display?: "none" | "flex";
//   elevation?: number;
//   direction?: "inherit" | "ltr" | "rtl";
// }
// color, space, size, borderWidth, borderRadius
//# sourceMappingURL=Box.js.map