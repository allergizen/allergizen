"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _SpacingFuncContext = require("./SpacingFuncContext");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const Box = _ref => {
  let {
    as,
    h,
    minH,
    maxH,
    w,
    minW,
    maxW,
    m,
    mt,
    mr,
    mb,
    ml,
    ms,
    me,
    mh,
    mv,
    p,
    pt,
    pr,
    pb,
    pl,
    ps,
    pe,
    ph,
    pv,
    borderStyle,
    border,
    borderTop,
    borderRight,
    borderBottom,
    borderLeft,
    borderStart,
    borderEnd,
    borderColor,
    borderTopColor,
    borderRightColor,
    borderBottomColor,
    borderLeftColor,
    borderStartColor,
    borderEndColor,
    radius,
    topLeftRadius,
    topRightRadius,
    bottomLeftRadius,
    bottomRightRadius,
    topStartRadius,
    topEndRadius,
    bottomStartRadius,
    bottomEndRadius,
    position,
    top,
    right,
    bottom,
    left,
    start,
    end,
    bg,
    opacity,
    zIndex,
    overflow,
    style,
    ...rest
  } = _ref;
  const spacingFunc = (0, _SpacingFuncContext.useSpacingFunc)();
  const boxStyle = (0, _react.useMemo)(() => {
    const styleObj = {};
    styleObj.height = spacingFunc(h);
    styleObj.minHeight = spacingFunc(minH);
    styleObj.maxHeight = spacingFunc(maxH);
    styleObj.width = spacingFunc(w);
    styleObj.minWidth = spacingFunc(minW);
    styleObj.maxWidth = spacingFunc(maxW);
    styleObj.margin = spacingFunc(m);
    styleObj.marginTop = spacingFunc(mt);
    styleObj.marginRight = spacingFunc(mr);
    styleObj.marginBottom = spacingFunc(mb);
    styleObj.marginLeft = spacingFunc(ml);
    styleObj.marginStart = spacingFunc(ms);
    styleObj.marginEnd = spacingFunc(me);
    styleObj.marginHorizontal = spacingFunc(mh);
    styleObj.marginVertical = spacingFunc(mv);
    styleObj.padding = spacingFunc(p);
    styleObj.paddingTop = spacingFunc(pt);
    styleObj.paddingRight = spacingFunc(pr);
    styleObj.paddingBottom = spacingFunc(pb);
    styleObj.paddingLeft = spacingFunc(pl);
    styleObj.paddingStart = spacingFunc(ps);
    styleObj.paddingEnd = spacingFunc(pe);
    styleObj.paddingHorizontal = spacingFunc(ph);
    styleObj.paddingVertical = spacingFunc(pv);
    styleObj.borderStyle = borderStyle;
    styleObj.borderWidth = border;
    styleObj.borderTopWidth = borderTop;
    styleObj.borderRightWidth = borderRight;
    styleObj.borderBottomWidth = borderBottom;
    styleObj.borderLeftWidth = borderLeft;
    styleObj.borderStartWidth = borderStart;
    styleObj.borderEndWidth = borderEnd;
    styleObj.borderColor = borderColor;
    styleObj.borderTopColor = borderTopColor;
    styleObj.borderRightColor = borderRightColor;
    styleObj.borderBottomColor = borderBottomColor;
    styleObj.borderLeftColor = borderLeftColor;
    styleObj.borderStartColor = borderStartColor;
    styleObj.borderEndColor = borderEndColor;
    styleObj.borderRadius = radius;
    styleObj.borderTopLeftRadius = topLeftRadius;
    styleObj.borderTopRightRadius = topRightRadius;
    styleObj.borderBottomLeftRadius = bottomLeftRadius;
    styleObj.borderBottomRightRadius = bottomRightRadius;
    styleObj.borderTopStartRadius = topStartRadius;
    styleObj.borderTopEndRadius = topEndRadius;
    styleObj.borderBottomStartRadius = bottomStartRadius;
    styleObj.borderBottomEndRadius = bottomEndRadius;
    styleObj.position = position;
    styleObj.top = top;
    styleObj.right = right;
    styleObj.bottom = bottom;
    styleObj.left = left;
    styleObj.start = start;
    styleObj.end = end;
    styleObj.backgroundColor = bg;
    styleObj.opacity = opacity;
    styleObj.zIndex = zIndex;
    styleObj.overflow = overflow;
    return styleObj;
  }, [h, minH, maxH, w, minW, maxW, m, mt, mr, mb, ml, ms, me, mh, mv, p, pt, pr, pb, pl, ps, pe, ph, pv, borderStyle, border, borderTop, borderRight, borderBottom, borderLeft, borderStart, borderEnd, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderStartColor, borderEndColor, radius, topLeftRadius, topRightRadius, bottomLeftRadius, bottomRightRadius, topStartRadius, topEndRadius, bottomStartRadius, bottomEndRadius, position, top, right, bottom, left, start, end, bg, opacity, zIndex, overflow, spacingFunc]);

  if (as) {
    return /*#__PURE__*/_react.default.cloneElement(as, {
      style: [boxStyle, style, as.props.style],
      ...rest
    });
  }

  return /*#__PURE__*/_react.default.createElement(_reactNative.View, _extends({
    style: [boxStyle, style]
  }, rest));
};

var _default = Box; // export interface FlexStyle {
//   backfaceVisibility?: "visible" | "hidden";
//   aspectRatio?: number;
//   display?: "none" | "flex";
//   elevation?: number;
//   direction?: "inherit" | "ltr" | "rtl";
// }
// color, space, size, borderWidth, borderRadius

exports.default = _default;
//# sourceMappingURL=Box.js.map