/// <reference types="react" />
export declare type Side = 'start' | 'end' | 'top' | 'bottom';
export declare type Corner = 'topStart' | 'topEnd' | 'bottomStart' | 'bottomEnd';
export declare type Size = {
    width: number | undefined;
    height: number | undefined;
};
export declare type CornerRadius = Record<Corner, number>;
export declare type CornerRadiusShadow = Record<`${Corner}Shadow`, number>;
export declare const cornersArray: readonly ["topStart", "topEnd", "bottomStart", "bottomEnd"];
/** Rounds the given size to a pixel perfect size. */
export declare const R: (value: number) => number;
/** Converts dp to pixels. */
export declare const P: (value: number) => number;
/** How many pixels for each dp. scale = pixels/dp */
export declare const scale: number;
/** Converts two sizes to pixel for perfect math, sums them and converts the result back to dp. */
export declare const sumDps: (a: number, b: number) => number;
/** Converts two sizes to pixel for perfect math, divides them and converts the result back to dp. */
export declare const divDps: (a: number, b: number) => number;
/**
 * [Android/ios?] [*4] A small safe margin for the svg sizes.
 *
 * It fixes some gaps that we had, as even that the svg size and the svg rect for example size were the same, this rect
 * would still strangely be cropped/clipped. We give this additional size to the svg so our rect/etc won't be unintendedly clipped.
 *
 * It doesn't mean 1 pixel, as RN uses dp sizing, it's just an arbitrary and big enough number.
 * */
export declare const additional: number;
/** Auxilary function to shorten code */
export declare function objFromKeys<KeysArray extends Readonly<string[]>, Rtn>(keys: KeysArray, fun: (key: KeysArray[number]) => Rtn): Record<KeysArray[number], Rtn>;
export declare const cornerToStyle: {
    readonly topLeft: readonly ["borderTopLeftRadius", "borderTopStartRadius"];
    readonly topRight: readonly ["borderTopRightRadius", "borderTopEndRadius"];
    readonly bottomLeft: readonly ["borderBottomLeftRadius", "borderBottomStartRadius"];
    readonly bottomRight: readonly ["borderBottomRightRadius", "borderBottomEndRadius"];
};
declare type RadialGradientProps = {
    id: string;
    top: boolean;
    left: boolean;
    radius: number;
    shadowRadius: number;
    startColorWoOpacity: string;
    startColorOpacity: number;
    endColorWoOpacity: string;
    endColorOpacity: number;
    paintInside: boolean;
};
export declare type RadialGradientPropsOmited = Omit<RadialGradientProps, `${'start' | 'end' | 'paintInside'}${string}`>;
export declare function radialGradient({ id, left, radius, shadowRadius, top, startColorWoOpacity, startColorOpacity, endColorWoOpacity, endColorOpacity, paintInside, }: RadialGradientProps): JSX.Element;
/**
 * Generates a sufficiently unique suffix to add to gradient ids and prevent collisions.
 *
 * https://github.com/SrBrahma/react-native-shadow-2/pull/54
 */
export declare const generateGradientIdSuffix: () => string;
export declare const rtlScaleX: {
    transform: {
        scaleX: number;
    }[];
};
/**
 * https://github.com/SrBrahma/react-native-shadow-2/issues/67
 */
export declare const rtlAbsoluteFillObject: {
    readonly position: "absolute";
    readonly start: 0;
    readonly end: 0;
    readonly top: 0;
    readonly bottom: 0;
};
export {};
